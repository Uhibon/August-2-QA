<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Flip + Swipe Slideshow (Mobile â€¢ No Margins)</title>
  <style>
    /* --- Reset / Base --- */
    html, body { height: 100%; }
    * { box-sizing: border-box; }
    body { margin: 0; background: #fff; color: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, system-ui, sans-serif; }

    /* --- Full-bleed stage --- */
    .stage { position: fixed; inset: 0; background: #fff; touch-action: pan-y; }

    /* --- Horizontal slider --- */
    .track { height: 100%; display: flex; transform: translate3d(var(--tx, 0px), 0, 0); transition: transform 260ms ease; will-change: transform; }
    .slide { flex: 0 0 100%; height: 100%; display: grid; place-items: center; }

    /* --- Flip card --- */
    .card { position: relative; width: 100vw; height: 100dvh; perspective: 1400px; }
    .card .inner { position: absolute; inset: 0; transform-style: preserve-3d; transition: transform 380ms cubic-bezier(.2,.7,.2,1); }
    .card.flipped .inner { transform: rotateY(180deg); }

    .face { position: absolute; inset: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); display: grid; place-items: center; backface-visibility: hidden; background: #fff; }
    .face.back { transform: rotateY(180deg); }

    .face img { width: 100%; height: 100%; object-fit: contain; display: block; }

    /* Minimal HUD (optional). Can be removed if you truly want nothing. */
    .hud { position: fixed; left: 8px; bottom: calc(8px + env(safe-area-inset-bottom)); font-size: 12px; opacity: .5; background: rgba(0,0,0,.05); color: #000; padding: 4px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <!-- Stage fills the screen, no margins/padding -->
  <div class="stage" id="stage" aria-roledescription="carousel" aria-label="Flip & Swipe Cards">
    <div class="track" id="track"></div>
  </div>
  <div class="hud" id="hud">1 / 22</div>

  <script>
    /* Config */
    const TOTAL_IMAGES = 44; // 01.jpg - 44.jpg
    const CARDS = TOTAL_IMAGES / 2; // 22
    const IMG_PATH = (n) => `${String(n).padStart(2, '0')}.jpg`;

    /* DOM */
    const stage = document.getElementById('stage');
    const track = document.getElementById('track');
    const hud = document.getElementById('hud');

    /* Build slides */
    const slides = [];
    for (let c = 0; c < CARDS; c++) {
      const nFront = c * 2 + 1;
      const nBack  = nFront + 1;

      const slide = document.createElement('section');
      slide.className = 'slide';

      const card = document.createElement('div');
      card.className = 'card';

      const inner = document.createElement('div');
      inner.className = 'inner';

      const faceF = document.createElement('div');
      faceF.className = 'face front';
      const imgF = document.createElement('img');
      imgF.alt = `Card ${c+1} front`;
      imgF.loading = 'lazy';
      imgF.dataset.src = IMG_PATH(nFront);
      faceF.appendChild(imgF);

      const faceB = document.createElement('div');
      faceB.className = 'face back';
      const imgB = document.createElement('img');
      imgB.alt = `Card ${c+1} back`;
      imgB.loading = 'lazy';
      imgB.dataset.src = IMG_PATH(nBack);
      faceB.appendChild(imgB);

      inner.appendChild(faceF);
      inner.appendChild(faceB);
      card.appendChild(inner);
      slide.appendChild(card);
      track.appendChild(slide);
      slides.push(slide);
    }

    /* State */
    let index = 0; // current card
    let w = stage.clientWidth;
    let baseTx = 0;

    // gesture state
    let dragging = false;
    let startX = 0;
    let curX = 0;
    let tapOK = false;
    let tapTimer = 0;

    const DRAG_THRESHOLD = 48; // px to change card
    const TAP_WIGGLE = 8;      // px tolerance for tap
    const TAP_TIME = 220;      // ms max for tap

    /* Helpers */
    function faceImgs(i) {
      const card = slides[i]?.querySelector('.card');
      if (!card) return {};
      return {
        front: card.querySelector('.front img'),
        back:  card.querySelector('.back img'),
        card
      };
    }

    function preload(i) {
      if (i < 0 || i >= CARDS) return;
      const { front, back } = faceImgs(i);
      if (front && !front.src) front.src = front.dataset.src;
      if (back && !back.src) back.src = back.dataset.src;
    }

    function setHud() {
      hud.textContent = `${index + 1} / ${CARDS}`;
    }

    function setTransform(tx, withTransition = true) {
      track.style.transition = withTransition ? 'transform 260ms ease' : 'none';
      track.style.setProperty('--tx', `${tx}px`);
    }

    function update() {
      w = stage.clientWidth;
      baseTx = -index * w;
      setTransform(baseTx, true);
      setHud();
      // Preload current & neighbors
      [index - 1, index, index + 1].forEach(preload);
    }

    function go(n) {
      // Loop
      index = (n + CARDS) % CARDS;
      // Always reset to front when moving
      const { card } = faceImgs(index);
      if (card) card.classList.remove('flipped');
      update();
    }

    function next() { go(index + 1); }
    function prev() { go(index - 1); }

    function flip() {
      const { card } = faceImgs(index);
      if (card) card.classList.toggle('flipped');
    }

    /* Resize */
    let rTO; window.addEventListener('resize', () => {
      clearTimeout(rTO);
      rTO = setTimeout(() => {
        w = stage.clientWidth;
        baseTx = -index * w;
        setTransform(baseTx, false);
      }, 100);
    });

    /* Pointer / Touch handlers */
    function onDown(x) {
      dragging = true; startX = x; curX = x;
      tapOK = true;
      clearTimeout(tapTimer);
      tapTimer = setTimeout(() => { tapOK = false; }, TAP_TIME);
      setTransform(baseTx, false);
    }
    function onMove(x) {
      if (!dragging) return;
      curX = x;
      const dx = curX - startX;
      if (Math.abs(dx) > TAP_WIGGLE) tapOK = false;
      setTransform(baseTx + dx, false);
    }
    function onUp() {
      if (!dragging) return; dragging = false; clearTimeout(tapTimer);
      const dx = curX - startX;
      if (tapOK && Math.abs(dx) <= TAP_WIGGLE) {
        flip();
        setTransform(baseTx, true);
        return;
      }
      if (Math.abs(dx) > DRAG_THRESHOLD) {
        if (dx < 0) next(); else prev();
      } else {
        setTransform(baseTx, true);
      }
    }

    // Bind
    stage.addEventListener('mousedown', (e) => onDown(e.clientX));
    window.addEventListener('mousemove', (e) => onMove(e.clientX));
    window.addEventListener('mouseup', onUp);

    stage.addEventListener('touchstart', (e) => onDown(e.touches[0].clientX), { passive: true });
    stage.addEventListener('touchmove',  (e) => onMove(e.touches[0].clientX),  { passive: true });
    stage.addEventListener('touchend', onUp, { passive: true });

    // Keyboard (desktop convenience)
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') next();
      if (e.key === 'ArrowLeft') prev();
      if (e.key === ' ') { e.preventDefault(); flip(); }
    });

    // Double-tap / double-click for fullscreen (optional)
    stage.addEventListener('dblclick', toggleFullscreen);
    stage.addEventListener('touchend', (e) => { if (e.detail === 2) toggleFullscreen(); }, { passive: true });

    function toggleFullscreen() {
      const el = document.documentElement;
      if (!document.fullscreenElement) el.requestFullscreen?.(); else document.exitFullscreen?.();
    }

    // Init
    update(); preload(index);
  </script>
</body>
</html>
